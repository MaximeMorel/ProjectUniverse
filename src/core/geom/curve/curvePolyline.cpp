////////////////////////////////////////////////////////////////////////////////
#include "curvePolyline.hpp"
////////////////////////////////////////////////////////////////////////////////
CurvePolyline::CurvePolyline(const Vec3& pointA, const Vec3& pointB)
    : m_points()
{
    addPoint(pointA);
    addPoint(pointB);
}
////////////////////////////////////////////////////////////////////////////////
CurvePolyline::~CurvePolyline()
{
}
////////////////////////////////////////////////////////////////////////////////
void CurvePolyline::addPoint(const Vec3& point)
{
    m_points.push_back(point);
}
////////////////////////////////////////////////////////////////////////////////
void CurvePolyline::setPoint(size_t id, const Vec3& point)
{
    if (id >= 0 && id < m_points.size())
    {
        m_points[id] = point;
    }
}
////////////////////////////////////////////////////////////////////////////////
const Vec3& CurvePolyline::getPoint(size_t id) const
{
    if (id >= 0 && id < m_points.size())
    {
        return m_points[id];
    }
    return m_points[0];
}
////////////////////////////////////////////////////////////////////////////////
Vec3 CurvePolyline::computePoint(double u) const
{
    return ((m_points[0] * (1.0 - u)) + (m_points[1]) * u);
}
////////////////////////////////////////////////////////////////////////////////
size_t CurvePolyline::getMemSize() const
{
    return sizeof(*this);
}
////////////////////////////////////////////////////////////////////////////////
Logger& operator<<(Logger& o, const CurvePolyline& curve)
{
    o << "Line curve: " << curve.m_points[0] << ", " << curve.m_points[1];
    for (const Vec3& v : curve.m_points)
    {
        o << "\t" << v << "\n";
    }
    o << std::flush;
    return o;
}
////////////////////////////////////////////////////////////////////////////////
