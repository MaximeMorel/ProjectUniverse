////////////////////////////////////////////////////////////////////////////////
#include "timer.hpp"
//#include <ctime>
#include <thread>
////////////////////////////////////////////////////////////////////////////////
Timer::Timer()
    : m_start(std::chrono::nanoseconds::zero())
{}
////////////////////////////////////////////////////////////////////////////////
void Timer::start()
{
    m_start = now();
}
////////////////////////////////////////////////////////////////////////////////
void Timer::pause()
{}
////////////////////////////////////////////////////////////////////////////////
void Timer::stop()
{}
////////////////////////////////////////////////////////////////////////////////
void Timer::reset()
{
    start();
}
////////////////////////////////////////////////////////////////////////////////
std::chrono::microseconds Timer::getTime() const
{
    return std::chrono::duration_cast<std::chrono::microseconds>(now() - m_start);
}
////////////////////////////////////////////////////////////////////////////////
void Timer::wait(std::chrono::microseconds microseconds)
{
    //std::chrono::duration
    std::this_thread::sleep_for(microseconds);
    /*struct timespec t;
    t.tv_sec = milliseconds / 1000;
    long milli = static_cast<long>(milliseconds) % 1000;
    long nano = 1000000 * (milliseconds - milli);
    t.tv_nsec = 1000000 * milli + nano;
    nanosleep(&t, nullptr);*/
}
////////////////////////////////////////////////////////////////////////////////
std::chrono::steady_clock::time_point Timer::now()
{
    return std::chrono::steady_clock::now();
    /*struct timespec t;
    int ret = clock_gettime(CLOCK_MONOTONIC, &t);
    if (ret < 0)
    {
        return 0;
    }

    return (1000.0 * t.tv_sec) + (t.tv_nsec / 1000000.0);*/
}
////////////////////////////////////////////////////////////////////////////////
Logger& operator<<(Logger& o, const Timer& timer)
{
    return o << timer.m_start.time_since_epoch().count();
}
////////////////////////////////////////////////////////////////////////////////
