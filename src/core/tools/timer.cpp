////////////////////////////////////////////////////////////////////////////////
#include "timer.hpp"
#include <ctime>
#include <chrono>
#include <thread>
////////////////////////////////////////////////////////////////////////////////
Timer::Timer()
    : m_start(0)
{}
////////////////////////////////////////////////////////////////////////////////
void Timer::start()
{
    m_start = now();
}
////////////////////////////////////////////////////////////////////////////////
void Timer::pause()
{}
////////////////////////////////////////////////////////////////////////////////
void Timer::stop()
{}
////////////////////////////////////////////////////////////////////////////////
void Timer::reset()
{
    start();
}
////////////////////////////////////////////////////////////////////////////////
double Timer::getTime() const
{
    return now() - m_start;
}
////////////////////////////////////////////////////////////////////////////////
void Timer::wait(double milliseconds)
{
    //std::chrono::duration
    std::this_thread::sleep_for(std::chrono::milliseconds(static_cast<int>(milliseconds)));
    /*struct timespec t;
    t.tv_sec = milliseconds / 1000;
    long milli = static_cast<long>(milliseconds) % 1000;
    long nano = 1000000 * (milliseconds - milli);
    t.tv_nsec = 1000000 * milli + nano;
    nanosleep(&t, nullptr);*/
}
////////////////////////////////////////////////////////////////////////////////
double Timer::now()
{
    struct timespec t;
    int ret = clock_gettime(CLOCK_MONOTONIC, &t);
    if (ret < 0)
    {
        return 0;
    }

    return (1000.0 * t.tv_sec) + (t.tv_nsec / 1000000.0);
}
////////////////////////////////////////////////////////////////////////////////
Logger& operator<<(Logger& o, const Timer& timer)
{
    return o << timer.m_start;
}
////////////////////////////////////////////////////////////////////////////////
